package com.slightlyloony.blog.objects;

import com.slightlyloony.blog.storage.StorageInputStream;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.nio.charset.Charset;
import java.text.MessageFormat;

/**
 * Represents an object stored on the blog, which could be metadata, static (including template generated) content, or content generated by code.
 * The class includes provision for either storing the encoded byte form of the object, or as an input stream with known length.  When an instance
 * of this class resides in a cache, it is <i>always</i> in encoded byte form, to minimize the memory consumed.  There are convenience methods
 * provided for transforming the content between either input stream or bytes, and also for creating instances from a string, or transforming it
 * to a string.
 *
 * @author Tom Dilatush  tom@dilatush.com
 */
public class BlogObject {

    private final static Logger LOG = LogManager.getLogger();

    private final BlogID id;
    private final BlogObjectType type;
    private byte[] content;
    private StorageInputStream contentStream;
    private boolean valid;
    private String errorMessage;


    private BlogObject( final BlogID _id, final BlogObjectType _type ) {

        if( (_id == null) || (_type == null) )
            throw new IllegalArgumentException( "Missing object ID or type" );

        id = _id;
        type = _type;
        valid = true;
        errorMessage = null;
        contentStream = null;
        content = null;
    }


    public BlogObject( final BlogID _id, final BlogObjectType _type, final StorageInputStream _contentStream ) {
        this( _id, _type );

        if( _contentStream == null )
            throw new IllegalArgumentException( "Missing content stream" );

        contentStream = _contentStream;
    }


    public BlogObject( final BlogID _id, final BlogObjectType _type, final byte[] _content ) {
        this( _id, _type );

        if( _content == null )
            throw new IllegalArgumentException( "Missing content data" );

        content = _content;
    }


    public BlogObject( final BlogID _id, final BlogObjectType _type, final String _content ) {
        this( _id, _type );

        if( _content == null )
            throw new IllegalArgumentException( "Missing content string" );

        content = _content.getBytes( Charset.forName( "UTF-8" ) );
    }


    public static BlogObject createInvalid( final BlogID _id, final BlogObjectType _type, final String _errorMessage ) {
        BlogObject result = new BlogObject( _id, _type );
        result.valid = false;
        result.errorMessage = _errorMessage;
        return result;
    }


    private void read() {

        if( (contentStream == null) )
            throw new IllegalStateException( "Attempted to non-existent input stream" );

        content = new byte[contentStream.length()];
        try( StorageInputStream sis = contentStream ) {
            int i = 0;
            while( i < content.length ) {
                int read = sis.read( content, i, content.length - i );
                if( read < 1 )
                    break;
                i += read;
            }
        }
        catch( IOException e ) {
            content = null;
            valid = false;
            errorMessage = MessageFormat.format( "Error reading file for the object {0}.{1}: {2}", id, type, e.getMessage() );
            LOG.error( errorMessage, e );
        }

        // get rid of our now-closed and useless stream...
        contentStream = null;
    }


    public byte[] getContentAsBytes() {

        // if we've already loaded the content bytes, just return them...
        if( content != null )
            return content;

        // otherwise, if we have an input stream then attempt to read the contents and return them...
        if( contentStream != null ) {
            read();
            return content;
        }

        // if we get here, we've failed miserably, so invalidate the object and leave a message...
        valid = false;
        errorMessage = MessageFormat.format( "No source for the object {0}.{1} content was available: ", id, type );
        LOG.warn( errorMessage );
        return null;
    }


    public String getContentAsUTF8String() {

        // get the bytes and convert them to a string, and return that...
        getContentAsBytes();
        if( content != null )
            return new String( content, Charset.forName( "UTF-8" ) );

        // if we get here, we've failed miserably and we've already invalidated and left a message, so just leave empty-handed...
        return null;
    }


    public StorageInputStream getContentAsStream() {

        // if we've already got the stream, just return it - but delete it from this object, as we'll now assume it's been consumed...
        if( contentStream != null ) {
            StorageInputStream result = contentStream;
            contentStream = null;
            return result;
        }

        // otherwise, if we have the content bytes or string, re-create the stream and provide it...
        getContentAsBytes();
        if( content != null ) {
            return new StorageInputStream( new ByteArrayInputStream( content ), content.length );
        }

        // if we get here, we've failed miserably and we've already invalidated and left a message, so just leave empty-handed...
        return null;
    }


    public boolean isValid() {
        return valid;
    }


    public String getErrorMessage() {
        return errorMessage;
    }


    public BlogID getBlogID() {
        return id;
    }


    public BlogObjectType getType() {
        return type;
    }


    public boolean hasBytes() {
        return content != null;
    }


    public boolean hasStream() {
        return contentStream != null;
    }


    public int size() {
        return 50 + ((content != null ) ? content.length : 0);  // assume fixed overhead of 50 bytes; close enough...
    }
}
